


import argparse
import glob
import os
import pyseq
import re
import sys

from wolfkrow import Loader

# Environment variables needed for Wolfkrow to function correctly.
wolfkrow_environment = {
    "PYSEQ_STRICT_PAD": "1",
}

os.environ.update(wolfkrow_environment)

def parse_args():
    parser = argparse.ArgumentParser(description="Ingest media into Wolfkrow Demo project.")
    
    parser.add_argument(
        "path",
        help="The root path of the media to ingest.",
    )

    parser.add_argument(
        "--export_option",
        help="The export option to use from the Wolfkrow workflow.",
        choices=["Demo Client Export - EXR Final", "Demo Client Export - Movs"],
        required=True,
    )

    return parser.parse_args(sys.argv[1:])

def main():
    args = parse_args()

    image_sequence_path = args.path
    
    context_regex = re.compile(
        r"shows[/\\](?P<show_name>[^/\\]+)[/\\]shots[\//](?P<sequence>\d{3}_\w{3})[/\\](?P<shot>\d{3}_\w{3}_\d{3})[/\\]"
    )
    context_match = re.search(context_regex, image_sequence_path)
    if not context_match:
        print("Error: Could not determine context from the provided path.")
        sys.exit(1)

    show_name = context_match.group("show_name")
    sequence = context_match.group("sequence")
    shot = context_match.group("shot")

    #"D:\wolfkrow_demo\shows\demo_show\client_io\in\2025_10_30\package_013\999_rnd_999_mp01_v01\8192x4320\999_rnd_999_mp01_v01.1001.exr"
    publish_template = re.compile(
        r"(?P<publish_type>\w+)[\\\\/](?P<publish_name>\w+)[/\\\\]v(?P<version>\d{3})[/\\\\]render[/\\\\](?P<shot>(?P<sequence>\d{3}_\w{3})_\d{3})_(?P=publish_name)_v(?P=version)[.](\d{4,5}|%(0\d+)?d)[.](?P<render_extension>\w+)"
    )
    results = {}
    seqs = pyseq.get_sequences(os.path.dirname(image_sequence_path))
    if len(seqs) == 0:
        print("Error: No image sequences found in the provided path.")
        return results

    seq = seqs[0]
    print(f"Exporting sequence: {seq}")
    path = seq.format("%D%h%p%t")
    match = re.search(publish_template, path)

    if not match:
        return results

    # The base replacements extracted from the file path
    replacements = match.groupdict()
    
    basename = os.path.basename(path).split(".")[0]
    replacements["basename"] = basename
    replacements["project_name"] = show_name
    replacements["sequence"] = sequence
    replacements["shot"] = shot

    replacements["start_frame"] = seq.start()
    replacements["start_frame_minusOne"] = seq.start() - 1
    replacements["end_frame"] = seq.end()
    replacements["user"] = "Jacob Clark"

    # We give the clients our internal version number
    replacements["client_version"] = replacements["version"]
    # The clients export_type request happens to map 1:1 with our internal publish_type
    replacements["export_type"] = replacements["publish_type"]

    replacements["submission_notes"] = "Demo export generated by Wolfkrow Delivery App."

    packages = glob.glob("$WOLFKROW_DEMO_ROOT/shows/demo_show/client_io/out/*/client_package_*")
    latest_package_number = 0
    for package_path in packages:
        package_number = os.path.basename(package_path).split("_")[-1]
        latest_package_number = max(latest_package_number, int(package_number))

    replacements["package_number"] = latest_package_number + 1

    replacements["input_path"] = path.replace("\\", "/")


    loader = Loader(
        replacements=replacements,
        temp_dir="$WOLFKROW_DEMO_ROOT/temp/DATE<%Y_%m_%d>/DATE<%H_%M_%S>",
    )
    task_graph = loader.parse_workflow(args.export_option)
    results = task_graph.execute_local()

    # Summarize the results
    print("\n")
    print("=" * 80)
    print("=" * 80)
    print("=" * 80)
    print("Client Export Results for {}:".format(basename))
    for task_name, result in results.items():
        result_str = "Success" if result else "Failed"
        print("    {:<50} - {}".format(task_name, result_str))
    print("=" * 80)
    print("=" * 80)
    print("=" * 80)

if __name__ == "__main__":
    main()